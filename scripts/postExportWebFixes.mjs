import fs from "node:fs";
import path from "node:path";
import crypto from "node:crypto";

// Vercel ignores any folder named `node_modules` (even inside static exports).
// Expo Web export currently places some image assets under:
//   dist/assets/node_modules/...
// which causes 404s in production. This script renames that folder and rewrites
// bundle references so the assets are served correctly.

const distDir = path.resolve(process.cwd(), "dist");
const fromDir = path.join(distDir, "assets", "node_modules");
const toDir = path.join(distDir, "assets", "nm");
const fromPrefix = "/assets/node_modules/";
const toPrefix = "/assets/nm/";
const dotEnvPath = path.resolve(process.cwd(), ".env");

function moveDir(from, to) {
  // On Windows, rename can fail with EPERM due to transient file locks.
  // Fall back to copy+delete.
  try {
    fs.renameSync(from, to);
    return;
  } catch (err) {
    const code = err?.code;
    if (code !== "EPERM" && code !== "EXDEV") throw err;
  }

  fs.cpSync(from, to, { recursive: true });
  fs.rmSync(from, { recursive: true, force: true });
}

function walkFiles(dir, out = []) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const ent of entries) {
    const p = path.join(dir, ent.name);
    if (ent.isDirectory()) walkFiles(p, out);
    else if (ent.isFile()) out.push(p);
  }
  return out;
}

function replaceInFile(filePath, find, replace) {
  const buf = fs.readFileSync(filePath);
  const text = buf.toString("utf8");
  if (!text.includes(find)) return 0;
  const next = text.split(find).join(replace);
  fs.writeFileSync(filePath, next, "utf8");
  return 1;
}

function sha256Hex(buf) {
  return crypto.createHash("sha256").update(buf).digest("hex");
}

function cleanString(v) {
  return typeof v === "string" ? v.trim() : "";
}

function parseDotEnv(text) {
  const out = {};
  const lines = String(text || "").split(/\r?\n/);
  for (const line of lines) {
    const raw = line.trim();
    if (!raw || raw.startsWith("#")) continue;
    const idx = raw.indexOf("=");
    if (idx === -1) continue;
    const key = raw.slice(0, idx).trim();
    let val = raw.slice(idx + 1).trim();
    if (!key) continue;
    if ((val.startsWith('"') && val.endsWith('"')) || (val.startsWith("'") && val.endsWith("'"))) {
      val = val.slice(1, -1);
    }
    out[key] = val;
  }
  return out;
}

function getEnvValue(key, dotEnvMap) {
  const fromProcess = cleanString(process.env[key]);
  if (fromProcess) return fromProcess;
  const fromFile = cleanString(dotEnvMap?.[key]);
  if (fromFile) return fromFile;

  // Monorepo compatibility: allow NEXT_PUBLIC_* to back-fill EXPO_PUBLIC_*.
  if (key.startsWith("EXPO_PUBLIC_")) {
    const nextKey = key.replace(/^EXPO_PUBLIC_/, "NEXT_PUBLIC_");
    const nextFromProcess = cleanString(process.env[nextKey]);
    if (nextFromProcess) return nextFromProcess;
    const nextFromFile = cleanString(dotEnvMap?.[nextKey]);
    if (nextFromFile) return nextFromFile;
  }

  return "";
}

function writeFirebaseMessagingServiceWorker({ dotEnvMap }) {
  const apiKey = getEnvValue("EXPO_PUBLIC_FIREBASE_API_KEY", dotEnvMap);
  const authDomain = getEnvValue("EXPO_PUBLIC_FIREBASE_AUTH_DOMAIN", dotEnvMap);
  const projectId = getEnvValue("EXPO_PUBLIC_FIREBASE_PROJECT_ID", dotEnvMap);
  const storageBucket = getEnvValue("EXPO_PUBLIC_FIREBASE_STORAGE_BUCKET", dotEnvMap);
  const messagingSenderId = getEnvValue("EXPO_PUBLIC_FIREBASE_MESSAGING_SENDER_ID", dotEnvMap);
  const appId = getEnvValue("EXPO_PUBLIC_FIREBASE_APP_ID", dotEnvMap);

  const missing = [];
  if (!apiKey) missing.push("EXPO_PUBLIC_FIREBASE_API_KEY");
  if (!authDomain) missing.push("EXPO_PUBLIC_FIREBASE_AUTH_DOMAIN");
  if (!projectId) missing.push("EXPO_PUBLIC_FIREBASE_PROJECT_ID");
  if (!storageBucket) missing.push("EXPO_PUBLIC_FIREBASE_STORAGE_BUCKET");
  if (!messagingSenderId) missing.push("EXPO_PUBLIC_FIREBASE_MESSAGING_SENDER_ID");
  if (!appId) missing.push("EXPO_PUBLIC_FIREBASE_APP_ID");
  if (missing.length > 0) {
    console.warn(`postExportWebFixes: skipping firebase-messaging-sw.js (missing ${missing.join(", ")})`);
    return;
  }

  const firebaseVersion = "10.12.2";
  const swPath = path.join(distDir, "firebase-messaging-sw.js");

  const sw = `/* eslint-disable */
/* Auto-generated by scripts/postExportWebFixes.mjs */
importScripts("https://www.gstatic.com/firebasejs/${firebaseVersion}/firebase-app-compat.js");
importScripts("https://www.gstatic.com/firebasejs/${firebaseVersion}/firebase-messaging-compat.js");

firebase.initializeApp({
  apiKey: ${JSON.stringify(apiKey)},
  authDomain: ${JSON.stringify(authDomain)},
  projectId: ${JSON.stringify(projectId)},
  storageBucket: ${JSON.stringify(storageBucket)},
  messagingSenderId: ${JSON.stringify(messagingSenderId)},
  appId: ${JSON.stringify(appId)},
});

const messaging = firebase.messaging();

messaging.onBackgroundMessage((payload) => {
  const data = payload && payload.data ? payload.data : {};
  const title = (data && data.title) || "ðŸš¨ SOS Alert";
  const body = (data && data.body) || "Tap to view location";
  const eventId = (data && data.eventId) || "";
  const type = (data && data.type) || "";

  self.registration.showNotification(title, {
    body,
    data: { type, eventId },
    requireInteraction: true,
  });
});

self.addEventListener("notificationclick", (event) => {
  event.notification.close();
  const data = (event.notification && event.notification.data) || {};
  const eventId = typeof data.eventId === "string" ? data.eventId : "";
  const url = eventId ? "/?sosEventId=" + encodeURIComponent(eventId) : "/";
  event.waitUntil(
    self.clients.matchAll({ type: "window", includeUncontrolled: true }).then((clientList) => {
      for (const client of clientList) {
        if (client && "navigate" in client) {
          client.navigate(url);
          if ("focus" in client) return client.focus();
        }
      }
      if (self.clients.openWindow) return self.clients.openWindow(url);
    }),
  );
});
`;

  fs.writeFileSync(swPath, sw, "utf8");
}

function validateFirebaseConfigInExport({ dotEnvMap }) {
  const projectId = getEnvValue("EXPO_PUBLIC_FIREBASE_PROJECT_ID", dotEnvMap);
  const messagingSenderId = getEnvValue("EXPO_PUBLIC_FIREBASE_MESSAGING_SENDER_ID", dotEnvMap);
  const appId = getEnvValue("EXPO_PUBLIC_FIREBASE_APP_ID", dotEnvMap);
  if (!projectId || !messagingSenderId || !appId) return;

  try {
    const jsDir = path.join(distDir, "_expo", "static", "js", "web");
    if (!fs.existsSync(jsDir)) return;

    const entries = fs.readdirSync(jsDir);
    const appEntry = entries.find((n) => /^AppEntry-[a-f0-9]+\.js$/.test(n));
    if (!appEntry) return;

    const text = fs.readFileSync(path.join(jsDir, appEntry), "utf8");
    const missing = [];
    if (!text.includes(projectId)) missing.push("projectId");
    if (!text.includes(messagingSenderId)) missing.push("messagingSenderId");
    if (!text.includes(appId)) missing.push("appId");

    if (missing.length > 0) {
      console.warn(
        `postExportWebFixes: Firebase config may be out of sync with the exported bundle (${missing.join(
          ", ",
        )} not found in ${appEntry}). Ensure EXPO_PUBLIC_FIREBASE_* env vars are set before running expo export.`,
      );
    }
  } catch (err) {
    console.warn("postExportWebFixes: failed to validate Firebase config in export:", err?.message || err);
  }
}

function main() {
  if (!fs.existsSync(distDir)) {
    console.error(`dist folder not found: ${distDir}`);
    process.exit(1);
  }

  let dotEnvMap = {};
  try {
    if (fs.existsSync(dotEnvPath)) {
      dotEnvMap = parseDotEnv(fs.readFileSync(dotEnvPath, "utf8"));
    }
  } catch {
    dotEnvMap = {};
  }

  // Move dist/assets/node_modules -> dist/assets/nm
  if (fs.existsSync(fromDir)) {
    if (fs.existsSync(toDir)) {
      fs.rmSync(toDir, { recursive: true, force: true });
    }
    moveDir(fromDir, toDir);
  }

  // Rewrite bundle references.
  const files = walkFiles(distDir).filter((p) => p.endsWith(".js"));
  let changed = 0;
  for (const f of files) {
    changed += replaceInFile(f, fromPrefix, toPrefix);
  }

  // Expo uses hashed bundle filenames and Vercel/browsers may cache them as immutable.
  // Since we just mutated the JS bundle contents, re-hash and rename AppEntry so clients
  // always fetch the updated bundle.
  try {
    const jsDir = path.join(distDir, "_expo", "static", "js", "web");
    if (fs.existsSync(jsDir)) {
      const entries = fs.readdirSync(jsDir);
      const appEntryFiles = entries.filter((n) => /^AppEntry-[a-f0-9]+\.js$/.test(n));
      for (const oldName of appEntryFiles) {
        const oldPath = path.join(jsDir, oldName);
        const buf = fs.readFileSync(oldPath);
        const nextHash = sha256Hex(buf).slice(0, 32);
        const newName = `AppEntry-${nextHash}.js`;
        if (newName === oldName) continue;

        const newPath = path.join(jsDir, newName);
        fs.writeFileSync(newPath, buf);
        fs.unlinkSync(oldPath);

        // Update index.html to point at the renamed bundle.
        const idx = path.join(distDir, "index.html");
        if (fs.existsSync(idx)) {
          replaceInFile(
            idx,
            `/_expo/static/js/web/${oldName}`,
            `/_expo/static/js/web/${newName}`,
          );
        }
      }
    }
  } catch (err) {
    console.warn("postExportWebFixes: failed to re-hash AppEntry bundle:", err?.message || err);
  }

  // Ensure firebase-messaging-sw.js exists in the static export so web push can work.
  try {
    writeFirebaseMessagingServiceWorker({ dotEnvMap });
  } catch (err) {
    console.warn("postExportWebFixes: failed to write firebase-messaging-sw.js:", err?.message || err);
  }

  // Warn if the exported JS bundle doesn't contain the expected Firebase config.
  validateFirebaseConfigInExport({ dotEnvMap });

  console.log(`postExportWebFixes: rewrote ${changed} JS file(s)`);
}

main();
