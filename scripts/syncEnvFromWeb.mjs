import fs from "fs";
import os from "os";
import path from "path";

function isPrivateIpv4(ip) {
  if (typeof ip !== "string") return false;
  if (ip.startsWith("10.")) return true;
  if (ip.startsWith("192.168.")) return true;
  const m = ip.match(/^172\.(\d{1,3})\./);
  if (!m) return false;
  const second = Number(m[1]);
  return second >= 16 && second <= 31;
}

function scoreCandidate(interfaceName, ip) {
  const name = String(interfaceName).toLowerCase();
  let score = 0;

  if (ip.endsWith(".1")) score -= 10;
  if (ip.startsWith("10.")) score += 5;
  if (ip.startsWith("192.168.")) score += 3;
  if (ip.startsWith("172.")) score += 2;

  if (name.includes("wi-fi") || name.includes("wifi") || name.includes("wlan") || name.includes("wireless")) {
    score += 50;
  }
  if (name.includes("ethernet")) score += 20;

  if (
    name.includes("vmware") ||
    name.includes("virtualbox") ||
    name.includes("vbox") ||
    name.includes("vethernet") ||
    name.includes("hyper-v") ||
    name.includes("docker") ||
    name.includes("wsl") ||
    name.includes("loopback") ||
    name.includes("vpn") ||
    name.includes("tailscale") ||
    name.includes("hamachi")
  ) {
    score -= 50;
  }

  if (name.includes("*")) score -= 20;

  return score;
}

function pickLanIp() {
  const net = os.networkInterfaces();
  /** @type {{ ip: string; name: string; score: number }[]} */
  const candidates = [];

  for (const [name, addrs] of Object.entries(net)) {
    for (const addr of addrs ?? []) {
      const family = typeof addr.family === "string" ? addr.family : addr.family === 4 ? "IPv4" : "IPv6";
      if (family !== "IPv4") continue;
      if (addr.internal) continue;
      if (!addr.address) continue;
      if (addr.address.startsWith("169.254.")) continue;
      if (addr.address.startsWith("127.")) continue;
      if (!isPrivateIpv4(addr.address)) continue;

      candidates.push({ ip: addr.address, name, score: scoreCandidate(name, addr.address) });
    }
  }

  candidates.sort((a, b) => b.score - a.score);
  return candidates[0]?.ip ?? null;
}

function parseEnvFile(text) {
  /** @type {Record<string, string>} */
  const out = {};
  for (const rawLine of String(text || "").split(/\r?\n/)) {
    const line = rawLine.trim();
    if (!line || line.startsWith("#")) continue;
    const idx = line.indexOf("=");
    if (idx === -1) continue;
    const key = line.slice(0, idx).trim();
    let value = line.slice(idx + 1).trim();
    if (
      (value.startsWith('"') && value.endsWith('"') && value.length >= 2) ||
      (value.startsWith("'") && value.endsWith("'") && value.length >= 2)
    ) {
      value = value.slice(1, -1);
    }
    if (key) out[key] = value;
  }
  return out;
}

function loadWebFirebasePublicConfig(repoRoot) {
  const candidates = [path.join(repoRoot, ".env.local"), path.join(repoRoot, ".env.example")];
  for (const p of candidates) {
    if (!fs.existsSync(p)) continue;
    const env = parseEnvFile(fs.readFileSync(p, "utf8"));
    const picked = Object.fromEntries(
      Object.entries(env).filter(([k]) => k.startsWith("NEXT_PUBLIC_FIREBASE_")),
    );
    if (Object.keys(picked).length > 0) return picked;
  }
  return {};
}

function main() {
  const projectRoot = process.cwd();
  const repoRoot = path.resolve(projectRoot, "..");

  const ip = pickLanIp();
  if (!ip) {
    console.error("Could not infer a LAN IPv4 address.");
    console.error("Run Expo with tunnel instead: npm run start:tunnel");
    process.exit(1);
  }

  const webFirebase = loadWebFirebasePublicConfig(repoRoot);

  /** @type {string[]} */
  const lines = [];
  lines.push("# Auto-generated by: npm run env:sync");
  lines.push(`# Generated at: ${new Date().toISOString()}`);
  lines.push("");
  lines.push(`# Laptop LAN IP: ${ip}`);
  lines.push(`EXPO_PUBLIC_API_BASE_URL=http://${ip}:3000`);
  lines.push(`EXPO_PUBLIC_N8N_BASE_URL=http://${ip}:5678`);

  if (Object.keys(webFirebase).length > 0) {
    lines.push("");
    lines.push("# Firebase (public web config copied from repo root)");
    for (const [k, v] of Object.entries(webFirebase)) {
      const expoKey = k.replace(/^NEXT_PUBLIC_/, "EXPO_PUBLIC_");
      lines.push(`${expoKey}=${v}`);
    }
  }

  lines.push("");

  const outPath = path.join(projectRoot, ".env");
  fs.writeFileSync(outPath, lines.join("\n"), "utf8");

  const writtenKeys = ["EXPO_PUBLIC_API_BASE_URL", "EXPO_PUBLIC_N8N_BASE_URL"].concat(
    Object.keys(webFirebase).map((k) => k.replace(/^NEXT_PUBLIC_/, "EXPO_PUBLIC_")),
  );

  console.log(`Wrote ${outPath}`);
  console.log("Keys:");
  for (const k of writtenKeys) console.log(`- ${k}`);
  console.log("");
  console.log("Restart Expo after changing env:");
  console.log("- Ctrl+C");
  console.log("- npm run start:clean:lan:ip");
}

main();

